<html>

<head>
    <title>Python</title>
    <link rel="stylesheet" href="../style.css">
</head>

<body>

    <header>
        <div class="header">
            <div>
                <nav>
                    <ul class="topmenu">
                      <li>
                        <div class="logo">
                          <a href="../index.html"> EAZY LEARNING. </a>
                        </div>
                      </li>
                      <li><a href="" class="down">Курсы &#9660;</a>
                        <ul class="submenu">
                          <li><a href="./course.html">Курсы от 16 лет </a></li>
                          <li><a href="./kids_course.html">Курсы для детей</a></li>
                        </ul>
                      </li>
                      <li><a href="" class="down">О нас &#9660;</a>
                        <ul class="submenu">
                          <li><a href="./comment.php">Отзывы</a></li>
                          <li><a href="./questions.html">Вопросы</a></li>
                        </ul>
                      </li>
                      <li><a href="" class="down">Полезная информация &#9660;</a>
                        <ul class="submenu">
                          <li><a href="./choosing_a_computer.html">Как выбрать компьютер для занятий</a></li>
                        </ul>
                      </li>
                      
                    </ul>
                  </nav>
                <div class="header-text">
                    <p>Python-разработчик </p>
                </div>
            </div>

        </div>
    </header>
    <article>


        <h3>5.2 Множества и словари</h3>
        <h2>Множества</h2>
        <p>Множества – структура данных, такая же, как и множества в математике. Если вы проходили теорию множеств в
            школе или университете, то вам будет просто понять, что это такое, и как с этим работать.</p>
        <code class="code">
        <p>a = {'a','b','c'}<br>
            print(a) # {'b', 'c', 'a'}</p></code><br>
        <p> Множество можно представить как прозрачный мешок, в котором хранятся уникальные карточки:</p>
        <ul>
            <li>Вы видите все карточки и можете однозначно определить какая карточка присутствует в мешке, а какая нет;
            </li><br>
            <li> Чтобы достать какую-либо карточку вам нужно сначала покопаться в мешке, чтобы найти ее.</li><br>
        </ul>
        <p> Если говорить терминами множеств, то:</p>
        <ul>
            <li>>Операция проверки на вхождение во множество очень быстрая, в лучшем случае – константна. Скорость
                проверки
                зависит от коллизий, хеш-функции и объема данных;</li><br>
            <li> Достать какой-либо элемент за константное время по индексу как это было в списках не получится, чтобы
                найти
                какой либо элемент нужно перебрать все;</li><br>
            <li>Элементы множества всегда уникальны;</li><br>
            <li>Добавление и удаление элементов в множество – всегда константно;</li><br>
            <li> Порядок, в котором находятся элементы множества – случайный;</li><br>
            <li>Элементы множества – обязательно неизменяемые объекты, которые можно хешировать (int, str, tuple, bool,
                ...).</li><br>
        </ul>
        <code class="code">
            print({'a','a','b'}) # {'b', 'a'}</code><br>
        <p> Базовые методы взаимодействия с множествами – len, add, in, remove.</p>
        <code class="code">
        <p>a = {'a','b','c'}</p>

        <p># считает длину множества<br>
            print(len(a)) # 3</p>

        <p># добавить элемент в множество<br>
            a.add('d')<br>
            print(a) # {'b', 'c', 'd', 'a'}</p>

        <p># проверить на вхождение<br>
            print('c' in a) # True</p>

        <p># удалить элемент из множества<br>
            a.remove('a')<br>
            print(a) # {'b','c', 'd'}</p></code><br>

        <h3> Создание множеств</h3><br>
        <code class="code">
           <p> a = set() # создать пустое множество<br>
            a = {'1','2'} # создать множество с несколькими константами<br>
            a = {input(), input()} # создать множество с 2-мя элементами введенными с клавиатуры<br>
            a = {input() for i in range(10)} # создать множество из 10 переменных</p>

        <br>
        <p># создать множество из n элементов (без генераторов) <br>
            n = 20<br>
            a = set()<br>
            for i in range(n):<br>
            a.add(input())</p></code>
        <br>
        <h2>Генераторы множеств a.k.a set comprehensions</h2><br>
        <p> Множества можно создавать и фильтровать при помощи генераторов.</p>
        <code class="code">
        <p>a = [1,2,3,4,5,6]</p>

        <p># множество состоящее из четных элементов<br>
            a_set = {i for i in a if i % 2 == 0 } # {'2','4','6'}<br>
            # ^ ^ ^<br>
            # элемент| элемент||фильтр<br>
            # множества| массива||по массиву</p></code><br>

        <p> Вместо элемента множества можно вставлять любые дополнительные операции, которые нужны для генерирования
            множества.</p>
        <code class="code">
        <p>a = [1,2,3,4,5,6]</p>

        <p># тернарный оператор применяет формулу к четным элементам, а нечетные оставляет без изменений<br>
            a_set = {i ** 2 + 1 if i % 2 == 0 else i for i in a}</p></code><br>
        </p>
        <h2>Операции с множествами</h2><br>
        <p>Копировать и очистить множество можно при помощи методов copy и clear</p>
        <code class="code">
        <p>a = {'a','b','c'}</p>

        <p># создать копию множества<br>
            b = a.copy()<br>
            # очистить множество<br>
            a.clear()</p></code><br>

        <p> С двумя разными множествами можно выполнять операции из математики.</p><br>
        <center> <img class="imgtext" src="../img/p23.png"></center>

        <br>
        <code class="code">
        <p>a = {'a','b','c'}<br>
            b = {'b', 'c', 'd'}</p>

        <p>print(a & b) # {'b', 'c'}<br>
            print(a | b) # {'a', 'b', 'c', 'd'}<br>
            print(a - b) # {'a'}</p></code><br>
        <p> Есть и другие, менее популярные операции над множествами, с которыми вы можете ознакомиться по ссылке.</p>

        <p>Так же можно проверить является ли одно множество – подмножеством другого.</p>
        <code class="code">
        <p>a = {'b','c'}<br>
            b = {'b', 'c', 'd'}</p>

        <p>print(a.issubset(b)) # True<br>
            print(b.issuperset(a)) # True</p></code>
        <h2>frozenset</h2><br>
        <p> Существует специальный неизменяемый тип, такой же как set.</p>

        <p>Его предназначение – защита от изменений содержимого множества извне. Обычно такое поведение нужно при
            написании библиотеки, чтобы обеспечить целостность выполнения кода.</p>

        <p>Если вы попробуете изменить frozenset, то получите ошибку.</p>
        <code class="code">
        <p>a = frozenset([1,2,3,4])<br>
            a.add(5)<br>
            #Traceback (most recent call last):<br>
            # File "	&lt;stdin>", line 1, in 	&lt;module><br>
                    #AttributeError: 'frozenset' object has no attribute 'add'</p></code><br>
        <p> Но все остальные методы работают так же, как и в set.</p>
        <code class="code">
        <p>a = frozenset([1,2,3,4])<br>
            print(1 in a) # True</p></code>

        <h2>Словари</h2><br>
        <p><b>Словари</b> – очень важная для Backend разработчика структура данных. При работе с REST обычно JSON-ы
            десериализуются именно в словарь, с которым дальше можно работать и как-то обрабатывать информацию, которая
            там хранится.</p>

        <p>От множеств словари отличаются тем, что тут есть два действующих лица – ключ и значение.</p>
        <code class="code">
        <p>d = {'user': 'Anton', 'country': 'Russia'}</p>

        <p>print(d['user']) # Anton<br>
            print(d['country']) # Russia</p></code><br>
        <p> <b>Ключи</b> словаря – это объект dict_keys, очень похожий на множество (set).</p>
        <code class="code">
        <p>d = {'user': 'Anton', 'country': 'Russia'}</p>

        <p>print(d.keys()) # dict_keys(['user', 'country'])</p></code><br>
        <b>Значения</b> словаря – любой объект Python.</p>
        <code class="code">
        <p>d = {'user': 'Anton', 'country': 'Russia'}</p>

        <p>print(d.values()) # dict_values(['Anton', 'Russia'])</p></code><br>
        <p> Создать пустой словарь можно двумя способами.</p>
        <code class="code">
        <p>d = {}<br>
            d = dict()</p></code><br>
        <p>Работа со словарями:</p>
        <code class="code">
        <p>user = {}</p>

        <p>user['name'] = 'Antony'<br>
            user['age'] = 24<br>
            user['country'] = 'Russia'</p>

        <p>print(user) # {'name': 'Antony', 'age': 24, 'country': 'Russia'}</p>

        <p>for key in user:<br>
            print(key)</p>

        <p># name<br>
            # age<br>
            # country</p>

        <p># items возвращает объект dict_items() вида ((key1, value1), (key2, value2), ...) очень похожий на кортеж<br>
            for key, value in user.items():<br>
            print(key, value)</p>

        <p># name Antony<br>
            # age 24<br>
            # country Russia</p></code><br>
        <p>Способы создания словаря:</p>
        <code class="code">
        <p>mobile = {'Anton': '+79000000000', 'Andrey': '+79000000001'}<br>
            mobile = dict(Anton='+79000000000', Andrey='+79000000001')<br>
            mobile = dict([('Anton', '+79000000000'), ('Andrey', '+79000000001')])<br>
            mobile = dict(zip(['Anton', 'Andrey'], ['+79000000000','+79000000001']))</p></code><br>
        <h2>Комплексные словари</h2><br>
        <p> В качестве значений словаря может быть любой объект, и это дает большую гибкость.</p>
        <code class="code">
        <p>users = [<br>
            {<br>
            "id": 1,<br>
            "name": "Anton",<br>
            "position": {<br>
            "name": "Backend",<br>
            "lang": "Python"<br>
            }<br>
            },<br>
            {<br>
            "id": 1,<br>
            "name": "Ivan",<br>
            "position": {<br>
            "name": "Frontend",<br>
            "lang": "JS"<br>
            }<br>
            },<br>
            ]</p>

        <p># Узнать язык программирования первого пользователя в списке<br>
            print(users[0]['position']['lang']) # Python</p></code>

        <p>Составные структуры данных позволяют хранить информацию в очень удобном виде.</p>

        <h2>Генераторы словарей a.k.a dict comprehensions</h2><br>
        <p>Распаковка словарей осуществляется следующим образом:</p>
        <code class="code">
        <p>a = {"name": "Anton", "val": "123"}<br>
            b = {"age": 24, "count": 143}</p>

        <p>c = {"status": 1, **a, **b} # ** распакуют словари, что позволит использовать их ключи в словаре c<br>
            print(c) # {'status': 1, 'name': 'Anton', 'val': '123', 'age': 24, 'count': 143}</p></code><br>

        <p> Начиная с версии 3.8 можно делать и так:</p>
        <code class="code">
        <p>a = {"name": "Anton", "val": "123"}<br>
            b = {"age": 24, "count": 143}</p>

        <p>c = {"status": 1} | a | b<br>
            print(c) # {'status': 1, 'name': 'Anton', 'val': '123', 'age': 24, 'count': 143}</p></code><br>
        <p>Применять генераторы словарей можно для создания в одну строку нужной структуры.</p>
        <code class="code">
        <p>a = [4,6,24,56]</p>

        <p># создать словарь с квадратами чисел<br>
            d = {i: i*i for i in a}<br>
            print(d) # {4: 16, 6: 36, 24: 576, 56: 3136}</p>

        <p># создать словарь с квадратами чисел и отфильтровать его<br>
            d = {i: i*i for i in a if i % 6 == 0}<br>
            print(d) # {6: 36, 24: 576}</p>

        <p># создать словарь с квадратами чисел, отфильтровать его и заменить ключи<br>
            d = {i if i == 24 else 'ff': i*i for i in a if i % 6 == 0}<br>
            print(d) # {'ff': 36, 24: 576}</p>

        <p># создать новый словарь из старого<br>
            old = {'name': 'Antony', 'status': 25}</p>

        <p>print({key: value for key, value in old.items()}) # {'name': 'Antony', 'status': 25}</p></code>
        <h2>match в dict</h2><br>
        <p> Словари можно использовать в конструкции match.</p>

        <p>Допустим вы делаете версионирование своего кода, и в первой версии, у вас был всего один автор. Затем пришел
            менеджмент и сказал, что нужно сделать возможность добавлять несколько авторов. При помощи match можно
            сохранить старое поведение и добавить новое.</p>
        <code class="code">
        <p>data = {"version": 1, "author": "Anton"}</p>

        <p>match data:<br>
            case {"version": 1, "author": name}:<br>
            print(name) # Anton<br>
            case {"version": 2, "authors": [*names]}:<br>
            print(*names)<br>
            case _:<br>
            print('Неизвестная версия')</p></code>

        <h2>Вариации словарей</h2><br>
           <h3> defaultdict</h3><br>
            <p>Этот словарь полезен тем, что имеет значение по умолчанию. Применение этого словаря упрощает чтение
            программы и уменьшает количество строк в части логики.</p>
            <code class="code">
        <p>d = {}<br>
            mass = ['a', 'a', 'b', 'b', 'b', 'c']</p>

        <p># Вариант без defaultdict<br>
            for i in mass:<br>
            if not d.get(i):<br>
            d[i] = 0<br>
            d[i] += 1</p>

        <p>print(d) # {'a': 2, 'b': 3, 'c': 1}</p>

        <p># С использованием defaultdict<br>
            from collections import defaultdict</p>

        <p>d = defaultdict(int) # значение по умолчанию 0</p>

        <p>for i in mass:<br>
            d[i] += 1</p>

        <p>print(d) # defaultdict(	&lt;class 'int'>, {'a': 2, 'b': 3, 'c': 1})</p></code><br>
                <h3>Counter</h3><br>
                <p></p>Этот словарь предназначен для удобных и быстрых расчетов количества появлений различных объектов в
                составных структурах данных.</p>
                <code class="code">
        <p>d = {}<br>
            mass = ['a', 'a', 'b', 'b', 'b', 'c']</p>

        <p># Вариант без Counter<br>
            for i in mass:<br>
            if not d.get(i):<br>
            d[i] = 0<br>
            d[i] += 1</p>

        <p>print(d) # {'a': 2, 'b': 3, 'c': 1}</p>

        <p># С использованием Counter<br>
            from collections import Counter</p>

        <p>d = Counter(mass)</p>

        <p>print(d) # Counter({'b': 3, 'a': 2, 'c': 1})</p>

        <p># список из наиболее распространенных элементов (можно ограничить количество параметром)<br>
            print(d.most_common()) # [('b', 3), ('a', 2), ('c', 1)]</p></code><br>
           <h3> OrderedDict</h3><br>
           <p> Этот словарь до версии 3.6 был очень полезен, так как сохранят порядок элементов в списке. Но после 3.6 dict
            тоже так делает. </p>

        <p>В документации Python описано для чего стоит использовать OrderedDict, и в основном это ситуации, когда
            словарь нужно часто сортировать.</p>

        <h3>ChainMap</h3><br>
            <p>Этот словарь помогает строить цепочки из словарей. Он может быть полезен при разработке интерпретаторов.</p>
            <code class="code">
        <p>d1 = dict(a=1, b=3)<br>
            d2 = dict(a=2, b=4, c=6)</p>

        <p>from collections import ChainMap</p>

        <p>chain = ChainMap(d1, d2)<br>
            print(chain['a']) # 1<br>
            print(chain['c']) # 6</p></code><br>
           <h3> Shelve</h3><br>
            <p>Это key-value хранилище, которое основано на бинарниках pickle. Его очень удобно использовать в локальной
            разработке, так как не нужно подключать и настраивать базы данных. Все хранится в бинарниках проекта. Этот
            модуль мы уже рассмотрим в следующем курсе.</p>


        <br> <a class="button_next" href="python5.3.html"><img src="next.png"></a>
    </article>
    <aside>
        1 Введение<br>
        <ul>

            <li><a href="python1.1.html">1.1 О курсе</a></li><br>
            <li><a href="python1.2.html">1.2 Установка Python и IDE</a></li><br>
            
        </ul>
        2  Данные<br>
        <ul>
            <li><a href="python2.1.html">2.1 Учим компьютер выводить результат</a></li><br>
            <li><a href="python2.2.html">2.2 Типы данных и переменные</a></li><br>
            <li><a href="python2.3.html">2.3 Возводим костыли</a></li><br>
           
        </ul>
        3  Арифметические операции<br>
        <ul>
            <li><a href="python3.1.html">3.1 Целые числа</a></li><br>
            <li><a href="python3.2.html">3.2 Числа с плавающей точкой </a></li><br>
            <li><a href="python3.3.html">3.3 Битовые операции</a></li><br>
            
        </ul>
        4  Основы Python: простые структуры данных и основные конструкции
        <ul>
            <li><a href="python4.1.html">4.1 Условия</a></li><br>
            <li><a href="python4.1.html">4.2 Циклы</a></li><br>
            <li><a href="python4.3.html">4.3 Работа со строками</a></li><br>
           
        </ul>
        5 Основы Python: составные структуры данных и дополнения<br>
        <ul>
            <li><a href="python5.1.html">5.1 Списки и кортежи</a></li><br>
            <li class="active"><a href="python5.2.html">5.2 Множества и словари</a></li><br>
            <li><a href="python5.3.html">5.3 Стек, очерерь, куча и дек </a></li><br>
            <li><a href="python5.4.html">5.4 Модули и библиотеки</a></li><br>
        </ul>
        6 Заключение<br>
        <ul>
            <li><a href="python6.1.html">6.1 Благодарности</a></li><br>
            <li><a href="python_test.html"> Итоговый тест по курсу</a></li><br>
           
        </ul>


    </aside>
    <footer>
        <div class="footer">
            <div>
    
              
            </div>
        </div>
    </footer>
</body>

</html>